name: Release on Breaking Change

on:
  push:
    branches: [master]
    paths:
      - 'dot/cli/**'
      - 'dot/sdk/**'

jobs:
  detect-breaking-change:
    runs-on: ubuntu-latest
    outputs:
      has_breaking: ${{ steps.check.outputs.has_breaking }}
      component: ${{ steps.check.outputs.component }}
      pr_number: ${{ steps.check.outputs.pr_number }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect breaking change
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Set default outputs first
            core.setOutput('has_breaking', 'false');
            core.setOutput('component', '');
            core.setOutput('pr_number', '');

            // Get the commit that triggered this push
            const commit = context.payload.head_commit;

            if (!commit) {
              console.log('No commit found');
              core.setOutput('has_breaking', 'false');
              core.setOutput('component', '');
              core.setOutput('pr_number', '');
              return;
            }

            // Extract PR number from commit message (format: "Merge pull request #123")
            const prMatch = commit.message.match(/#(\d+)/);

            if (!prMatch) {
              console.log('Not a PR merge commit, skipping');
              core.setOutput('has_breaking', 'false');
              core.setOutput('component', '');
              core.setOutput('pr_number', '');
              return;
            }

            const prNumber = parseInt(prMatch[1]);
            core.setOutput('pr_number', prNumber);

            // Get PR details to check for semantic:major label
            try {
              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
              });

              const labels = pr.data.labels.map(l => l.name);
              const hasBreakingLabel = labels.includes('semantic:major');

              if (!hasBreakingLabel) {
                console.log('No semantic:major label found');
                core.setOutput('has_breaking', 'false');
                core.setOutput('component', '');
                return;
              }

              // Check which component changed
              const files = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
              });

              const changedFiles = files.data.map(f => f.filename);
              const cliChanged = changedFiles.some(f => f.startsWith('dot/cli/'));
              const sdkChanged = changedFiles.some(f => f.startsWith('dot/core/'));

              if (cliChanged || sdkChanged) {
                core.setOutput('has_breaking', 'true');
                core.setOutput('component', cliChanged ? 'CLI' : 'SDK');
                console.log(`Breaking change detected in ${cliChanged ? 'CLI' : 'SDK'}`);
              } else {
                core.setOutput('has_breaking', 'false');
                core.setOutput('component', '');
              }
            } catch (error) {
              console.log(`Error fetching PR: ${error.message}`);
              core.setOutput('has_breaking', 'false');
              core.setOutput('component', '');
              core.setOutput('pr_number', '');
            }

      - name: Log detection result
        run: |
          echo "Has breaking change: ${{ steps.check.outputs.has_breaking }}"
          echo "Component: ${{ steps.check.outputs.component }}"
          echo "PR: ${{ steps.check.outputs.pr_number }}"

  get-cli-version:
    needs: detect-breaking-change
    if: needs.detect-breaking-change.outputs.has_breaking == 'true' && needs.detect-breaking-change.outputs.component == 'CLI'
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version.outputs.new }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get current CLI version
        id: version
        run: |
          # Extract version from Cargo.toml
          CURRENT_VERSION=$(grep "^version" dot/cli/Cargo.toml | head -1 | awk '{print $3}' | tr -d '"')
          echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Bump major version for breaking change
          MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
          NEW_VERSION="$((MAJOR + 1)).0.0"
          echo "new=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New CLI version: $NEW_VERSION"

  release-cli:
    needs: [detect-breaking-change, get-cli-version]
    if: needs.detect-breaking-change.outputs.has_breaking == 'true' && needs.detect-breaking-change.outputs.component == 'CLI'
    uses: ./.github/workflows/release-cli.yml
    permissions:
      contents: write
    with:
      version: ${{ needs.get-cli-version.outputs.new_version }}
      is_breaking: true
    secrets: inherit

  release-sdk:
    needs: detect-breaking-change
    if: needs.detect-breaking-change.outputs.has_breaking == 'true' && needs.detect-breaking-change.outputs.component == 'SDK'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Get current SDK version
        id: version
        run: |
          # Extract version from Cargo.toml
          CURRENT_VERSION=$(grep "^version" dot/core/Cargo.toml | head -1 | awk '{print $3}' | tr -d '"')
          echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Bump major version
          MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
          MINOR=$(echo $CURRENT_VERSION | cut -d. -f2)
          NEW_VERSION="$((MAJOR + 1)).0.0"
          echo "new=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New SDK version: $NEW_VERSION"

      - name: Build and test SDK
        run: |
          cd dot/core
          cargo build --release --locked
          cargo test --release --locked

      - name: Create SDK release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_VERSION: ${{ steps.version.outputs.new }}
          PR_NUMBER: ${{ needs.detect-breaking-change.outputs.pr_number }}
        run: |
          TAG_NAME="sdk-v$NEW_VERSION"

          # Create release notes
          cat > /tmp/sdk-release-notes.md <<'EOF'
          <div align="center">
            <img height="24px" alt="Polkadot" src="https://github.com/paritytech/polkadot-sdk/raw/master/docs/images/Polkadot_Logo_Horizontal_Pink_White.png#gh-dark-mode-only" />
            <img height="24px" alt="Polkadot" src="https://github.com/paritytech/polkadot-sdk/raw/master/docs/images/Polkadot_Logo_Horizontal_Pink_Black.png#gh-light-mode-only" />
          </div>

          EOF

          cat >> /tmp/sdk-release-notes.md <<EOF
          # Cookbook SDK v$NEW_VERSION

          **âš ï¸ Breaking Change Release**

          This is a breaking change release of the SDK library. All recipes have been retested
          and a new recipe release will follow automatically.

          ## Installation

          Add to your \`Cargo.toml\`:

          \`\`\`toml
          [dependencies]
          polkadot-cookbook-sdk = { git = "https://github.com/polkadot-developers/polkadot-cookbook.git", tag = "sdk-v$NEW_VERSION" }
          \`\`\`

          ## Changes

          See PR #${PR_NUMBER} for details.

          ---

          **Note:** This is a breaking change. Please update your dependencies accordingly.

          <div align="center">

          Built by [Polkadot Developers](https://github.com/polkadot-developers)

          [Recipes](https://github.com/polkadot-developers/polkadot-cookbook#-recipes) â€¢ [Contributing](https://github.com/polkadot-developers/polkadot-cookbook/blob/master/CONTRIBUTING.md) â€¢ [Issues](https://github.com/polkadot-developers/polkadot-cookbook/issues)

          </div>
          EOF

          # Create tag and release
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a $TAG_NAME -m "SDK Release v$NEW_VERSION (breaking)"
          git push origin $TAG_NAME

          gh release create $TAG_NAME \
            --title "Cookbook SDK v$NEW_VERSION (Breaking Change)" \
            --notes-file /tmp/sdk-release-notes.md

  test-and-release-recipes:
    needs: [detect-breaking-change, release-cli, release-sdk]
    if: |
      always() &&
      needs.detect-breaking-change.outputs.has_breaking == 'true' &&
      (needs.release-cli.result == 'success' || needs.release-sdk.result == 'success')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          components: rustfmt, clippy

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Test all recipes
        id: test
        run: |
          echo "Testing all recipes with updated CLI/SDK..."

          # Test each recipe
          for recipe in recipes/*/; do
            recipe_name=$(basename "$recipe")
            echo "Testing $recipe_name..."

            if [ -f "$recipe/Cargo.toml" ]; then
              cd "$recipe"
              cargo test --all-features --locked || exit 1
              cd ../..
            elif [ -f "$recipe/package.json" ]; then
              cd "$recipe"
              if grep -q "\"test\":" package.json; then
                npm install || exit 1

                # Check if recipe needs Chopsticks
                if grep -q "\"chopsticks\":" package.json; then
                  echo "Starting Chopsticks for $recipe_name..."
                  npm run chopsticks > chopsticks.log 2>&1 &
                  CHOPSTICKS_PID=$!

                  # Wait for Chopsticks to initialize (max 2 minutes)
                  echo "Waiting for Chopsticks to initialize..."
                  timeout 120 bash -c '
                    until grep -q "RPC listening" chopsticks.log 2>/dev/null; do
                      sleep 2
                      echo "Still waiting for Chopsticks..."
                    done
                  ' || {
                    echo "Chopsticks failed to start within 2 minutes"
                    cat chopsticks.log
                    exit 1
                  }

                  echo "Chopsticks is ready!"
                  tail -20 chopsticks.log

                  # Run tests
                  npm test || {
                    echo "Tests failed, stopping Chopsticks..."
                    kill $CHOPSTICKS_PID || true
                    pkill -f chopsticks || true
                    cat chopsticks.log
                    exit 1
                  }

                  # Stop Chopsticks
                  echo "Stopping Chopsticks..."
                  kill $CHOPSTICKS_PID || true
                  pkill -f chopsticks || true
                else
                  # No Chopsticks needed, just run tests
                  npm test || exit 1
                fi
              fi
              cd ../..
            fi
          done

      - name: Get last recipe release
        id: last_release
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 --match "v*.*.*" 2>/dev/null || echo "v0.0.0")
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT

      - name: Calculate new version
        id: new_version
        env:
          LAST_TAG: ${{ steps.last_release.outputs.last_tag }}
        run: |
          # For breaking change, we bump minor in alpha (v0.x.0)
          VERSION_NO_V=${LAST_TAG#v}
          MAJOR=$(echo $VERSION_NO_V | cut -d. -f1)
          MINOR=$(echo $VERSION_NO_V | cut -d. -f2)
          PATCH=$(echo $VERSION_NO_V | cut -d. -f3)

          if [ "$MAJOR" = "0" ]; then
            # In alpha, bump minor for breaking changes
            NEW_VERSION="v0.$((MINOR + 1)).0"
          else
            # Post-alpha, bump major for breaking changes
            NEW_VERSION="v$((MAJOR + 1)).0.0"
          fi

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New recipe version: $NEW_VERSION"

      - name: Generate release manifest
        env:
          NEW_VERSION: ${{ steps.new_version.outputs.new_version }}
          COMPONENT: ${{ needs.detect-breaking-change.outputs.component }}
        run: |
          mkdir -p .github/releases/$NEW_VERSION

          # Generate manifest (similar to weekly release)
          cat > .github/releases/$NEW_VERSION/manifest.yml <<EOF
          release: $NEW_VERSION
          release_date: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
          status: alpha
          triggered_by: ${COMPONENT}_breaking_change

          tooling:
            rust: "$(rustc --version | awk '{print $2}')"
            node: "$(node --version 2>/dev/null || echo 'N/A')"

          recipes:
          EOF

          # Add each recipe
          for recipe_dir in recipes/*/; do
            if [ ! -d "$recipe_dir" ]; then continue; fi

            recipe_name=$(basename "$recipe_dir")
            config_file="$recipe_dir/recipe.config.yml"

            if [ -f "$config_file" ]; then
              version=$(grep "^version:" "$config_file" | awk '{print $2}' || echo "0.1.0")
              difficulty=$(grep "^difficulty:" "$config_file" | awk '{print $2}' || echo "unknown")
              description=$(grep "^description:" "$config_file" | sed 's/^description: //' || echo "No description")
              commit_hash=$(git log -1 --format="%H" -- "$recipe_dir" | head -c 10)

              cat >> .github/releases/$NEW_VERSION/manifest.yml <<EOF
            $recipe_name:
              version: "$version"
              path: "recipes/$recipe_name"
              tested: true
              commit: "$commit_hash"
              difficulty: "$difficulty"
              description: "$description"
          EOF
            fi
          done

      - name: Generate release notes
        env:
          NEW_VERSION: ${{ steps.new_version.outputs.new_version }}
          COMPONENT: ${{ needs.detect-breaking-change.outputs.component }}
          PR_NUMBER: ${{ needs.detect-breaking-change.outputs.pr_number }}
        run: |
          cat > .github/releases/$NEW_VERSION/RELEASE_NOTES.md <<EOF
          # Release $NEW_VERSION

          **âš ï¸ Breaking Change Release**

          Released: $(date -u +"%Y-%m-%d")

          This release was triggered by a breaking change in the ${COMPONENT}.
          All recipes have been retested and verified to work with the updated tooling.

          ## Trigger

          - ${COMPONENT} breaking change (PR #${PR_NUMBER})

          ## Compatibility

          This release was tested with:
          - Rust: $(rustc --version | awk '{print $2}')
          - Node.js: $(node --version 2>/dev/null || echo 'N/A')

          ## Testing

          All recipes have been retested and passed with the new ${COMPONENT} version.

          Full manifest: [manifest.yml](./manifest.yml)

          ---

          **Status:** Alpha (v0.x.x)
          EOF

      - name: Create release branch and PR
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_VERSION: ${{ steps.new_version.outputs.new_version }}
          COMPONENT: ${{ needs.detect-breaking-change.outputs.component }}
          PR_NUMBER: ${{ needs.detect-breaking-change.outputs.pr_number }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create and switch to release branch
          BRANCH_NAME="release/$NEW_VERSION"
          git checkout -b $BRANCH_NAME

          # Commit release files
          git add .github/releases/$NEW_VERSION/
          git commit -m "chore(release): $NEW_VERSION triggered by breaking change"

          # Push branch
          git push origin $BRANCH_NAME

          # Create PR
          gh pr create \
            --title "Release $NEW_VERSION (Breaking Change)" \
            --body "$(cat <<'PRBODY'
          ## Breaking Change Release $NEW_VERSION

          âš ï¸ This PR contains the release manifest and notes for version $NEW_VERSION, triggered by a breaking change in the **$COMPONENT**.

          ### Changes
          - Triggered by: ${COMPONENT} breaking change (PR #${PR_NUMBER})
          - All recipes retested successfully
          - Release manifest generated
          - Release notes generated

          ### Next Steps
          Once this PR is merged:
          1. A Git tag will be created automatically
          2. A GitHub Release will be published
          3. Release artifacts will be attached

          ---

          ðŸ¤– This PR was automatically created by the Release on Breaking Change workflow.
          PRBODY
          )" \
            --label "semantic:major" \
            --label "release"

      - name: PR Created
        run: |
          echo "âœ… Release PR created successfully!"
          echo "Once the PR is merged, a separate workflow will:"
          echo "  - Create the Git tag $NEW_VERSION"
          echo "  - Publish the GitHub Release"
