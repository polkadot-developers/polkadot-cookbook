name: Auto-Label Semantic Version

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  analyze-commits:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Install cargo-semver-checks
        run: |
          cargo install cargo-semver-checks --locked

      - name: Fetch base branch for comparison
        run: |
          git fetch origin ${{ github.base_ref }}

      - name: Check for API breaking changes
        id: semver-check
        continue-on-error: true
        run: |
          echo "Checking for API breaking changes in SDK..."

          HAS_BREAKING=false

          # Note: CLI crate is skipped - it's binary-only with no public library API
          # Only check core/SDK crate which has a public library API

          if [ -d "core" ]; then
            echo "Checking core/SDK crate for API breaking changes..."
            echo "Comparing current code against base branch: ${{ github.base_ref }}"

            cd core

            # Use --baseline-rev to compare against base branch (works for unpublished crates)
            if ! cargo semver-checks check-release \
                --baseline-rev origin/${{ github.base_ref }} \
                2>&1 | tee /tmp/core-semver.log; then
              echo "âš ï¸ API breaking changes detected in SDK"
              HAS_BREAKING=true
            else
              echo "âœ“ No API breaking changes detected in SDK"
            fi

            cd ..
          fi

          echo "has_breaking=$HAS_BREAKING" >> $GITHUB_OUTPUT

          # Save logs for comment
          if [ "$HAS_BREAKING" = "true" ]; then
            echo "SEMVER_BREAKING=true" >> $GITHUB_ENV
            cp /tmp/core-semver.log /tmp/semver-report.log 2>/dev/null || true
          fi

      - name: Analyze commits and apply label
        uses: actions/github-script@v7
        env:
          SEMVER_BREAKING: ${{ steps.semver-check.outputs.has_breaking }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Guard: only run on pull_request events
            if (context.eventName !== 'pull_request') {
              console.log(`Skipping: workflow triggered by '${context.eventName}' event, not 'pull_request'`);
              return;
            }

            const pr = context.payload.pull_request;

            // Check if semantic label already exists (manual override)
            const existingLabels = pr.labels.map(l => l.name);
            const hasManualLabel = existingLabels.some(l => l.startsWith('semantic:'));

            if (hasManualLabel) {
              console.log('Manual semantic label already applied, respecting override');
              return;
            }

            // Get all commits in this PR
            const commits = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
            });

            let hasMajor = false;
            let hasMinor = false;
            let hasPatch = false;
            const analyzedCommits = [];

            // Analyze each commit message
            for (const commit of commits.data) {
              const message = commit.commit.message;
              const firstLine = message.split('\n')[0];

              console.log(`Analyzing: ${firstLine}`);

              // Match conventional commit pattern
              // Examples:
              // feat(recipe): add feature
              // fix(recipe): bug fix
              // feat(recipe)!: breaking change
              // feat!: breaking change
              const match = firstLine.match(/^(feat|fix|chore|docs|refactor|test|perf|style|ci|build)(\(.+\))?(!)?:/);

              if (match) {
                const type = match[1];
                const scope = match[2] || '';
                const hasBreaking = match[3] === '!' || message.includes('BREAKING CHANGE:');

                let impact = 'none';
                if (hasBreaking) {
                  hasMajor = true;
                  impact = 'MAJOR';
                } else if (type === 'feat') {
                  hasMinor = true;
                  impact = 'MINOR';
                } else if (['fix', 'perf'].includes(type)) {
                  hasPatch = true;
                  impact = 'PATCH';
                }

                analyzedCommits.push({
                  sha: commit.sha.substring(0, 7),
                  type,
                  scope,
                  breaking: hasBreaking,
                  impact,
                  message: firstLine
                });
              } else {
                console.log(`  âš ï¸  Commit does not follow conventional commits format`);
                analyzedCommits.push({
                  sha: commit.sha.substring(0, 7),
                  impact: 'INVALID',
                  message: firstLine
                });
              }
            }

            // Check for API breaking changes detected by cargo-semver-checks
            const semverBreaking = process.env.SEMVER_BREAKING === 'true';
            if (semverBreaking) {
              console.log('âš ï¸  API breaking changes detected by cargo-semver-checks');
              hasMajor = true;
              analyzedCommits.push({
                sha: 'semver',
                type: 'API',
                scope: '',
                breaking: true,
                impact: 'MAJOR',
                message: 'Breaking API changes detected by cargo-semver-checks'
              });
            }

            // Determine highest semantic level
            let semanticLevel = null;
            if (hasMajor) {
              semanticLevel = 'major';
            } else if (hasMinor) {
              semanticLevel = 'minor';
            } else if (hasPatch) {
              semanticLevel = 'patch';
            } else {
              // No version bump needed (only chore, docs, etc)
              semanticLevel = 'none';
            }

            console.log(`\nDetermined semantic level: ${semanticLevel}`);

            // Apply semantic label
            if (semanticLevel !== 'none') {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: [`semantic:${semanticLevel}`],
              });
            }

            // Build analysis table
            let table = '| Commit | Type | Impact | Message |\n';
            table += '|--------|------|--------|----------|\n';
            for (const commit of analyzedCommits) {
              const impactEmoji = {
                'MAJOR': 'ğŸ”´',
                'MINOR': 'ğŸŸ¡',
                'PATCH': 'ğŸŸ¢',
                'INVALID': 'âš ï¸',
                'none': 'âšª'
              }[commit.impact] || 'âšª';

              table += `| \`${commit.sha}\` | ${commit.type || 'invalid'} | ${impactEmoji} ${commit.impact} | ${commit.message.substring(0, 60)}${commit.message.length > 60 ? '...' : ''} |\n`;
            }

            // Create comment explaining the decision
            const versionBumpText = semanticLevel !== 'none'
              ? `**${semanticLevel.toUpperCase()}** version bump`
              : 'No version bump required';

            const apiBreakingNote = semverBreaking
              ? '\n\nâš ï¸ **API Breaking Changes Detected**\n\nThe `cargo-semver-checks` tool detected breaking changes in the SDK public API. This will trigger a MAJOR version bump (or MINOR in alpha v0.x.x).\n\n**Note:** Only the SDK/core library is checked for API breaking changes. The CLI is binary-only and has no public library API to check.\n'
              : '';

            const commentBody = `## ğŸ¤– Semantic Version Analysis

            **Result:** ${versionBumpText}
            ${apiBreakingNote}
            ### Commit Analysis

            ${table}

            ### Summary
            - SDK API breaking changes (ğŸ”´ MAJOR): ${semverBreaking ? 'âœ“ Detected by cargo-semver-checks' : 'âœ—'}
            - Conventional breaking changes (ğŸ”´ MAJOR): ${hasMajor && !semverBreaking ? 'âœ“' : 'âœ—'}
            - New features (ğŸŸ¡ MINOR): ${hasMinor ? 'âœ“' : 'âœ—'}
            - Bug fixes (ğŸŸ¢ PATCH): ${hasPatch ? 'âœ“' : 'âœ—'}

            ${semanticLevel !== 'none' ? `This PR will trigger a **${semanticLevel.toUpperCase()}** version bump when merged.` : 'This PR contains only non-versioned changes (docs, chore, etc).'}

            ---

            **Manual override:** If this is incorrect, you can manually add one of these labels:
            - \`semantic:major\` - Breaking changes
            - \`semantic:minor\` - New features
            - \`semantic:patch\` - Bug fixes
            - \`semantic:none\` - No version bump

            Once a manual label is added, this workflow will respect it and not override.`;

            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: commentBody
            });
