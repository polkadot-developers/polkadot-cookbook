name: Weekly Recipe Release

on:
  schedule:
    # Every Wednesday at 9:00 AM Bangkok Time (02:00 UTC)
    - cron: '0 2 * * 3'

  workflow_dispatch:  # Allow manual trigger
    inputs:
      version_bump:
        description: 'Force version bump type'
        required: false
        type: choice
        options:
          - 'auto'
          - 'major'
          - 'minor'
          - 'patch'
        default: 'auto'
      skip_tests:
        description: 'Skip recipe tests (use with caution!)'
        required: false
        type: boolean
        default: false

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.check.outputs.has_changes }}
      version_bump: ${{ steps.check.outputs.version_bump }}
      last_tag: ${{ steps.last_release.outputs.last_tag }}
      new_version: ${{ steps.check.outputs.new_version }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Get last release
        id: last_release
        run: |
          # Get last recipe release tag (v*.*.*)
          LAST_TAG=$(git describe --tags --abbrev=0 --match "v*.*.*" 2>/dev/null || echo "v0.0.0")
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT
          echo "Last release: $LAST_TAG"

      - name: Analyze changes since last release
        id: check
        env:
          LAST_TAG: ${{ steps.last_release.outputs.last_tag }}
          FORCE_BUMP: ${{ github.event.inputs.version_bump }}
        run: |
          echo "has_changes=true" >> $GITHUB_OUTPUT

          # Get all commits since last tag (including squash-merged PRs)
          if [ "$LAST_TAG" = "v0.0.0" ]; then
            echo "No previous release tag found"
            ALL_COMMITS=$(git log --pretty=format:"%s %b" || echo "")
          else
            ALL_COMMITS=$(git log $LAST_TAG..HEAD --pretty=format:"%s %b" || echo "")
          fi

          if [ -z "$ALL_COMMITS" ]; then
            echo "No changes since last release"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check for manual version bump override
          if [ "$FORCE_BUMP" != "auto" ] && [ -n "$FORCE_BUMP" ]; then
            echo "Using manual version bump: $FORCE_BUMP"
            echo "version_bump=$FORCE_BUMP" >> $GITHUB_OUTPUT
          else
            # Determine version bump from commit messages
            # Priority: breaking > feat > fix
            # Look for:
            # - "BREAKING CHANGE" or "breaking change" in commit body
            # - "feat:" or "feature:" prefix (new feature)
            # - "fix:" prefix (bug fix)
            # - Conventional commit types

            if echo "$ALL_COMMITS" | grep -qiE "(BREAKING CHANGE|breaking change)"; then
              echo "Detected breaking change in commits"
              echo "version_bump=major" >> $GITHUB_OUTPUT
            elif echo "$ALL_COMMITS" | grep -qiE "^(feat|feature|refactor)\("; then
              echo "Detected feature or refactor in commits"
              echo "version_bump=minor" >> $GITHUB_OUTPUT
            elif echo "$ALL_COMMITS" | grep -qiE "^(fix|chore|docs|test|ci)\("; then
              echo "Detected fix/chore/docs in commits"
              echo "version_bump=patch" >> $GITHUB_OUTPUT
            else
              echo "No conventional commit prefix found, defaulting to patch"
              echo "version_bump=patch" >> $GITHUB_OUTPUT
            fi
          fi

          # Calculate new version with alpha versioning rules
          BUMP_TYPE=$(grep "version_bump=" $GITHUB_OUTPUT | cut -d'=' -f2)
          CURRENT_VERSION=$LAST_TAG

          # Parse version (remove 'v' prefix)
          VERSION_NO_V=${CURRENT_VERSION#v}
          MAJOR=$(echo $VERSION_NO_V | cut -d. -f1)
          MINOR=$(echo $VERSION_NO_V | cut -d. -f2)
          PATCH=$(echo $VERSION_NO_V | cut -d. -f3)

          # Alpha versioning (v0.x.x): major bumps become minor bumps
          if [ "$MAJOR" = "0" ] && [ "$BUMP_TYPE" = "major" ]; then
            echo "Alpha versioning: treating major bump as minor bump"
            BUMP_TYPE="minor"
          fi

          case $BUMP_TYPE in
            major)
              NEW_VERSION="v$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEW_VERSION="v${MAJOR}.$((MINOR + 1)).0"
              ;;
            patch)
              NEW_VERSION="v${MAJOR}.${MINOR}.$((PATCH + 1))"
              ;;
          esac

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version will be: $NEW_VERSION"

  test-recipes:
    needs: check-changes
    if: needs.check-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust
        if: ${{ github.event.inputs.skip_tests != 'true' }}
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          components: rustfmt, clippy

      - name: Cache Rust dependencies
        if: ${{ github.event.inputs.skip_tests != 'true' }}
        uses: Swatinem/rust-cache@v2

      - name: Setup Node.js
        if: ${{ github.event.inputs.skip_tests != 'true' }}
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Test all recipes
        if: ${{ github.event.inputs.skip_tests != 'true' }}
        run: |
          # TODO: Implement test-all command in CLI
          # For now, test each recipe individually
          for recipe in recipes/*/; do
            recipe_name=$(basename "$recipe")
            echo "Testing $recipe_name..."

            # Check if recipe has tests
            if [ -f "$recipe/Cargo.toml" ]; then
              cd "$recipe"
              cargo test --all-features --locked || exit 1
              cd ../..
            elif [ -f "$recipe/package.json" ]; then
              cd "$recipe"
              if grep -q "\"test\":" package.json; then
                npm install || exit 1

                # Check if recipe needs Chopsticks
                if grep -q "\"chopsticks\":" package.json; then
                  echo "Starting Chopsticks for $recipe_name..."
                  npm run chopsticks > chopsticks.log 2>&1 &
                  CHOPSTICKS_PID=$!

                  # Wait for Chopsticks to initialize (max 2 minutes)
                  echo "Waiting for Chopsticks to initialize..."
                  timeout 120 bash -c '
                    until grep -q "RPC listening" chopsticks.log 2>/dev/null; do
                      sleep 2
                      echo "Still waiting for Chopsticks..."
                    done
                  ' || {
                    echo "Chopsticks failed to start within 2 minutes"
                    cat chopsticks.log
                    exit 1
                  }

                  echo "Chopsticks is ready!"
                  tail -20 chopsticks.log

                  # Run tests
                  npm test || {
                    echo "Tests failed, stopping Chopsticks..."
                    kill $CHOPSTICKS_PID || true
                    pkill -f chopsticks || true
                    cat chopsticks.log
                    exit 1
                  }

                  # Stop Chopsticks
                  echo "Stopping Chopsticks..."
                  kill $CHOPSTICKS_PID || true
                  pkill -f chopsticks || true
                else
                  # No Chopsticks needed, just run tests
                  npm test || exit 1
                fi
              fi
              cd ../..
            fi
          done

  create-release:
    needs: [check-changes, test-recipes]
    if: needs.check-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Generate release manifest
        env:
          NEW_VERSION: ${{ needs.check-changes.outputs.new_version }}
          LAST_TAG: ${{ needs.check-changes.outputs.last_tag }}
        run: |
          mkdir -p .github/releases/$NEW_VERSION

          # Generate manifest by reading recipe.config.yml files
          cat > .github/releases/$NEW_VERSION/manifest.yml <<EOF
          release: $NEW_VERSION
          release_date: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
          status: alpha

          tooling:
            rust: "$(rustc --version | awk '{print $2}')"
            node: "$(node --version 2>/dev/null || echo 'N/A')"

          recipes:
          EOF

          # Add each recipe to manifest
          for recipe_dir in recipes/*/; do
            if [ ! -d "$recipe_dir" ]; then continue; fi

            recipe_name=$(basename "$recipe_dir")
            config_file="$recipe_dir/recipe.config.yml"

            if [ -f "$config_file" ]; then
              version=$(grep "^version:" "$config_file" | awk '{print $2}' || echo "0.1.0")
              difficulty=$(grep "^difficulty:" "$config_file" | awk '{print $2}' || echo "unknown")
              description=$(grep "^description:" "$config_file" | sed 's/^description: //' || echo "No description")
              commit_hash=$(git log -1 --format="%H" -- "$recipe_dir" | head -c 10)

              cat >> .github/releases/$NEW_VERSION/manifest.yml <<EOF
            $recipe_name:
              version: "$version"
              path: "recipes/$recipe_name"
              tested: true
              commit: "$commit_hash"
              difficulty: "$difficulty"
              description: "$description"
          EOF
            fi
          done

      - name: Generate release notes
        env:
          NEW_VERSION: ${{ needs.check-changes.outputs.new_version }}
          LAST_TAG: ${{ needs.check-changes.outputs.last_tag }}
          VERSION_BUMP: ${{ needs.check-changes.outputs.version_bump }}
        run: |
          cat > .github/releases/$NEW_VERSION/RELEASE_NOTES.md <<EOF
          # Release $NEW_VERSION

          Released: $(date -u +"%Y-%m-%d")

          ## Changes Since $LAST_TAG

          **Version Bump:** ${VERSION_BUMP^^}

          ### Changes

          EOF

          # Get all commits since last release (including squash-merged PRs)
          if [ "$LAST_TAG" = "v0.0.0" ]; then
            # First release - show all commits with PR numbers
            git log --pretty=format:"- %s (%h)" | grep -E "\(#[0-9]+\)" >> .github/releases/$NEW_VERSION/RELEASE_NOTES.md || \
            git log --pretty=format:"- %s (%h)" >> .github/releases/$NEW_VERSION/RELEASE_NOTES.md
          else
            # Subsequent releases - show commits since last tag
            git log $LAST_TAG..HEAD --pretty=format:"- %s (%h)" | grep -E "\(#[0-9]+\)" >> .github/releases/$NEW_VERSION/RELEASE_NOTES.md || \
            git log $LAST_TAG..HEAD --pretty=format:"- %s (%h)" >> .github/releases/$NEW_VERSION/RELEASE_NOTES.md
          fi

          cat >> .github/releases/$NEW_VERSION/RELEASE_NOTES.md <<EOF


          ## Compatibility

          This release was tested with:
          - Rust: $(rustc --version | awk '{print $2}')
          - Node.js: $(node --version 2>/dev/null || echo 'N/A')

          ## Testing

          All recipes have passed CI tests.

          Full manifest: [manifest.yml](./manifest.yml)

          ---

          **Status:** Alpha (v0.x.x)
          EOF

      - name: Update workspace version
        env:
          NEW_VERSION: ${{ needs.check-changes.outputs.new_version }}
        run: |
          # Remove 'v' prefix for Cargo.toml (e.g., v0.11.0 -> 0.11.0)
          CARGO_VERSION=${NEW_VERSION#v}

          # Update workspace version in root Cargo.toml
          sed -i "s/^version = \".*\"/version = \"$CARGO_VERSION\"/" Cargo.toml

          echo "Updated Cargo.toml workspace version to $CARGO_VERSION"

      - name: Create release branch and PR
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_VERSION: ${{ needs.check-changes.outputs.new_version }}
          VERSION_BUMP: ${{ needs.check-changes.outputs.version_bump }}
          LAST_TAG: ${{ needs.check-changes.outputs.last_tag }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create and switch to release branch
          BRANCH_NAME="release/$NEW_VERSION"
          git checkout -b $BRANCH_NAME

          # Commit release files and updated Cargo.toml
          git add .github/releases/$NEW_VERSION/ Cargo.toml
          git commit -m "chore(release): add manifest and notes for $NEW_VERSION"

          # Push branch
          git push origin $BRANCH_NAME

          # Create PR
          gh pr create \
            --title "Release $NEW_VERSION" \
            --body "$(cat <<PRBODY
          ## Weekly Recipe Release $NEW_VERSION

          This PR contains the release manifest and notes for version $NEW_VERSION.

          ### Changes
          - Version bump: **$VERSION_BUMP** (from $LAST_TAG)
          - All recipes tested successfully
          - Release manifest generated
          - Release notes generated

          ### Next Steps
          Once this PR is merged:
          1. A Git tag will be created automatically
          2. A GitHub Release will be published
          3. Release artifacts will be attached

          ---

          This PR was automatically created by the Weekly Recipe Release workflow.
          PRBODY
          )" \
            --label "semantic:patch" \
            --label "release"

      - name: PR Created
        run: |
          echo "âœ… Release PR created successfully!"
          echo "Once the PR is merged, a separate workflow will:"
          echo "  - Create the Git tag $NEW_VERSION"
          echo "  - Publish the GitHub Release"
