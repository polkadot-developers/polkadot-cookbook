---
title: {{title}}
description: {{description}}
{{pathway}}
---

# {{title}}

> A standalone FRAME pallet template for focused pallet development.

## Overview

This recipe provides a minimal setup for developing and testing FRAME pallets in isolation. Perfect for learning pallet development or creating standalone pallets that will be integrated into existing runtimes.

**What you'll build:**
- A standalone FRAME pallet with storage, events, and extrinsics
- Unit tests with mocked runtime
- Benchmarking setup (optional)

**Who this is for:**
- Developers learning FRAME pallet development
- Teams creating reusable pallet libraries
- Anyone wanting to test pallets without full runtime complexity

## Prerequisites

Before starting, ensure you have:

- **Rust {{rust_version}}+** - The Polkadot SDK requires a recent Rust toolchain
- **Basic knowledge** of Rust and blockchain concepts

## Project Structure

```
recipes/{{slug}}/
├── Cargo.toml              # Workspace configuration
├── rust-toolchain.toml     # Rust version specification
└── pallets/
    └── template/
        ├── Cargo.toml      # Pallet dependencies
        └── src/
            ├── lib.rs      # Main pallet logic
            ├── mock.rs     # Mock runtime for tests
            ├── tests.rs    # Unit tests
            ├── benchmarking.rs  # Benchmarks (optional)
            └── weights.rs  # Weight calculations
```

## Getting Started

### 1. Build the Pallet

```bash
cd recipes/{{slug}}
cargo build --release
```

### 2. Run Tests

```bash
cargo test
```

### 3. Run Benchmarks (Optional)

```bash
cargo test --features runtime-benchmarks
```

## Development Workflow

### Understanding the Pallet Structure

The template pallet demonstrates core FRAME concepts:

**Storage**: Persistent state stored on-chain
```rust
#[pallet::storage]
pub type Something<T> = StorageValue<_, u32>;
```

**Events**: Notifications of state changes
```rust
#[pallet::event]
pub enum Event<T> {
    SomethingStored { value: u32, who: T::AccountId },
}
```

**Errors**: Typed error handling
```rust
#[pallet::error]
pub enum Error<T> {
    NoneValue,
    StorageOverflow,
}
```

**Extrinsics**: Functions users can call
```rust
#[pallet::call]
impl<T: Config> Pallet<T> {
    pub fn do_something(origin: OriginFor<T>, something: u32) -> DispatchResult {
        // Implementation
    }
}
```

### Testing Your Pallet

The mock runtime (`src/mock.rs`) provides a lightweight environment for testing:

```rust
#[test]
fn it_works_for_default_value() {
    new_test_ext().execute_with(|| {
        // Test your pallet here
    });
}
```

### Customizing the Pallet

1. **Modify Storage**: Add or change storage items in `lib.rs`
2. **Add Events**: Define new events for important state changes
3. **Implement Logic**: Write your pallet's business logic in extrinsics
4. **Write Tests**: Cover edge cases in `tests.rs`
5. **Add Benchmarks**: Measure computational costs in `benchmarking.rs`

## Integration into a Runtime

Once your pallet is ready, integrate it into a full runtime:

1. Add your pallet as a dependency in the runtime's `Cargo.toml`
2. Configure the pallet in `runtime/src/lib.rs`
3. Add it to the `construct_runtime!` macro
4. Run runtime tests to verify integration

## Resources

- [FRAME Documentation](https://paritytech.github.io/polkadot-sdk/master/frame_support/index.html)
- [Pallet Development Guide](https://docs.substrate.io/build/custom-pallets/)
- [Polkadot SDK](https://github.com/paritytech/polkadot-sdk)

## Next Steps

- Implement your custom storage and logic
- Write comprehensive unit tests
- Add benchmarking for weight calculations
- Consider integrating into a full parachain runtime

## Support

Having issues? Check out:
- [Polkadot Stack Exchange](https://substrate.stackexchange.com/)
- [Polkadot Forum](https://forum.polkadot.network/)
- [GitHub Discussions](https://github.com/paritytech/polkadot-sdk/discussions)
