---
title: {{title}}
description: {{description}}

---

# {{title}}

{{description}}

## Overview

A focused guide for implementing cross-chain interactions using XCM (Cross-Consensus Messaging). This guide shows you how to transfer assets between chains and execute remote operations.

**Prerequisites:**
- Node.js 20+
- Understanding of Polkadot architecture
- PAPI knowledge (see basic-interaction guide)

## Quick Start

```bash
cd recipes/{{slug}}
npm install

# Start local test chains
npm run chopsticks

# Run tests (in another terminal)
npm test
```

## XCM Basics

### Locations

XCM uses hierarchical locations to identify chains and accounts:

```typescript
// Relay chain from parachain
const relayChain = {
  V4: {
    parents: 1,
    interior: "Here"
  }
};

// Sibling parachain
const sibling = {
  V4: {
    parents: 1,
    interior: { X1: { Parachain: 1000 } }
  }
};

// Account on remote chain
const account = {
  V4: {
    parents: 0,
    interior: {
      X1: {
        AccountId32: {
          id: accountBytes,
          network: null
        }
      }
    }
  }
};
```

**Key rules:**
- `parents: 0` = same level
- `parents: 1` = up to parent (relay chain)
- `interior` = path within consensus

### Assets

Define assets to transfer:

```typescript
// Native token
const nativeAsset = {
  V4: [
    {
      id: { parents: 0, interior: "Here" },
      fun: { Fungible: amount }
    }
  ]
};

// Foreign asset
const foreignAsset = {
  V4: [
    {
      id: {
        parents: 0,
        interior: {
          X2: [
            { PalletInstance: 50 },
            { GeneralIndex: assetId }
          ]
        }
      },
      fun: { Fungible: amount }
    }
  ]
};
```

## Common Transfers

### Transfer to Relay Chain

```typescript
async function transferToRelay(amount: bigint, beneficiary: string) {
  const tx = api.tx.PolkadotXcm.transfer_assets({
    dest: {
      V4: { parents: 1, interior: "Here" }
    },
    beneficiary: {
      V4: {
        parents: 0,
        interior: {
          X1: {
            AccountId32: {
              id: decodeAddress(beneficiary),
              network: null
            }
          }
        }
      }
    },
    assets: {
      V4: [
        {
          id: { parents: 0, interior: "Here" },
          fun: { Fungible: amount }
        }
      ]
    },
    fee_asset_item: 0,
    weight_limit: "Unlimited"
  });

  return await tx.signAndSubmit(signer);
}
```

### Transfer Between Siblings

```typescript
async function transferToSibling(
  paraId: number,
  amount: bigint,
  beneficiary: string
) {
  const tx = api.tx.PolkadotXcm.transfer_assets({
    dest: {
      V4: {
        parents: 1,
        interior: { X1: { Parachain: paraId } }
      }
    },
    beneficiary: {
      V4: {
        parents: 0,
        interior: {
          X1: {
            AccountId32: {
              id: decodeAddress(beneficiary),
              network: null
            }
          }
        }
      }
    },
    assets: {
      V4: [
        {
          id: { parents: 1, interior: "Here" }, // Relay token
          fun: { Fungible: amount }
        }
      ]
    },
    fee_asset_item: 0,
    weight_limit: "Unlimited"
  });

  return await tx.signAndSubmit(signer);
}
```

### Reserve Transfer

Use when transferring through a reserve chain:

```typescript
const tx = api.tx.PolkadotXcm.limited_reserve_transfer_assets({
  dest,
  beneficiary,
  assets,
  fee_asset_item: 0,
  weight_limit: "Unlimited"
});
```

### Teleport Transfer

For trusted chains (relay <-> system parachains):

```typescript
const tx = api.tx.PolkadotXcm.limited_teleport_assets({
  dest,
  beneficiary,
  assets,
  fee_asset_item: 0,
  weight_limit: "Unlimited"
});
```

## Remote Execution

### Execute Call on Remote Chain

```typescript
async function remoteExecute(paraId: number, call: any, weight: bigint) {
  const message = {
    V4: [
      {
        WithdrawAsset: {
          assets: [
            {
              id: { parents: 1, interior: "Here" },
              fun: { Fungible: weight }
            }
          ]
        }
      },
      {
        BuyExecution: {
          fees: {
            id: { parents: 1, interior: "Here" },
            fun: { Fungible: weight }
          },
          weight_limit: "Unlimited"
        }
      },
      {
        Transact: {
          origin_kind: "SovereignAccount",
          require_weight_at_most: {
            ref_time: weight,
            proof_size: 0
          },
          call: { encoded: call }
        }
      }
    ]
  };

  const tx = api.tx.PolkadotXcm.send({
    dest: {
      V4: {
        parents: 1,
        interior: { X1: { Parachain: paraId } }
      }
    },
    message
  });

  return await tx.signAndSubmit(signer);
}
```

## Monitoring XCM

### Track Transfer Events

```typescript
api.query.System.Events.watchValue((events) => {
  for (const event of events) {
    // Message sent
    if (event.type === "PolkadotXcm.Sent") {
      console.log("XCM sent:", event.data);
    }

    // Execution success
    if (event.type === "XcmpQueue.Success") {
      console.log("XCM succeeded:", event.data);
    }

    // Execution failure
    if (event.type === "XcmpQueue.Fail") {
      console.error("XCM failed:", event.data);
    }

    // Assets trapped
    if (event.type === "PolkadotXcm.AssetsTrapped") {
      console.warn("Assets trapped:", event.data);
    }
  }
});
```

### Check Trapped Assets

```typescript
// Query trapped assets
const trapped = await api.query.PolkadotXcm.AssetTraps.getEntries();

// Claim trapped assets
const claimTx = api.tx.PolkadotXcm.claim_assets({
  assets,
  beneficiary
});
```

## Testing with Chopsticks

### Configuration

`chopsticks.yml`:

```yaml
relay_chain:
  endpoint: wss://westend-rpc.polkadot.io
  block: latest

parachains:
  - id: 1000
    endpoint: wss://westend-asset-hub-rpc.polkadot.io
    block: latest

  - id: 1002
    endpoint: wss://westend-collectives-rpc.polkadot.io
    block: latest
```

### Test Structure

```typescript
import { describe, it, expect, beforeAll } from "vitest";
import { setupChains } from "@acala-network/chopsticks-testing";

describe("XCM Transfers", () => {
  let relayChain, assetHub;

  beforeAll(async () => {
    const chains = await setupChains({
      relaychain: "westend",
      parachains: [{ paraId: 1000, chain: "westend-asset-hub" }]
    });

    relayChain = chains.relaychain;
    assetHub = chains.parachains[0];
  });

  it("transfers to relay chain", async () => {
    // Execute transfer
    await transferToRelay(1000000000n, account);

    // Progress chains
    await assetHub.newBlock();
    await relayChain.newBlock();

    // Verify balance
    const balance = await getBalance(relayChain, account);
    expect(balance).toBeGreaterThan(0n);
  });
});
```

### Running Tests

```bash
# Terminal 1: Start Chopsticks
npm run chopsticks

# Terminal 2: Run tests
npm test

# Watch mode
npm run test:watch
```

## Common Patterns

### Pattern 1: Check Balance Before Transfer

```typescript
async function safeTransfer(dest, amount, beneficiary) {
  const account = await api.query.System.Account.getValue(sender);
  const balance = account.data.free;

  if (balance < amount + estimatedFees) {
    throw new Error("Insufficient balance");
  }

  return await transferAssets(dest, amount, beneficiary);
}
```

### Pattern 2: Batch Transfers

```typescript
async function batchTransfer(transfers: Array<TransferParams>) {
  const calls = transfers.map(({ dest, amount, beneficiary }) =>
    api.tx.PolkadotXcm.transfer_assets({
      dest,
      beneficiary,
      assets: createAssets(amount),
      fee_asset_item: 0,
      weight_limit: "Unlimited"
    })
  );

  const batchTx = api.tx.Utility.batch({ calls });
  return await batchTx.signAndSubmit(signer);
}
```

### Pattern 3: Wait for Confirmation

```typescript
async function transferAndWait(dest, amount, beneficiary) {
  let confirmed = false;

  const unsubEvents = api.query.System.Events.watchValue((events) => {
    for (const event of events) {
      if (event.type === "XcmpQueue.Success") {
        confirmed = true;
      }
    }
  });

  await transferAssets(dest, amount, beneficiary);

  // Wait for confirmation
  while (!confirmed) {
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }

  unsubEvents();
}
```

### Pattern 4: Retry on Failure

```typescript
async function transferWithRetry(dest, amount, beneficiary, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await transferAssets(dest, amount, beneficiary);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      console.log(`Retry ${i + 1}/${maxRetries}...`);
      await new Promise((resolve) => setTimeout(resolve, 2000));
    }
  }
}
```

## Asset Types

### Native Chain Assets

```typescript
// Current chain's native token
const nativeAsset = {
  id: { parents: 0, interior: "Here" },
  fun: { Fungible: amount }
};
```

### Relay Chain Assets

```typescript
// Relay chain token on parachain
const relayAsset = {
  id: { parents: 1, interior: "Here" },
  fun: { Fungible: amount }
};
```

### Foreign Assets

```typescript
// Asset from another parachain
const foreignAsset = {
  id: {
    parents: 1,
    interior: {
      X2: [
        { Parachain: sourceParaId },
        { GeneralIndex: assetId }
      ]
    }
  },
  fun: { Fungible: amount }
};
```

## Error Handling

### Common Errors

```typescript
try {
  await transferToSibling(1000, amount, beneficiary);
} catch (error) {
  switch (error.type) {
    case "NotHoldingFees":
      console.error("Insufficient fees");
      break;
    case "AssetNotFound":
      console.error("Asset not recognized");
      break;
    case "TooExpensive":
      console.error("Exceeds weight limit");
      break;
    case "InvalidLocation":
      console.error("Invalid destination");
      break;
    default:
      console.error("Unknown error:", error);
  }
}
```

### Handling Trapped Assets

```typescript
async function handleTrappedAssets() {
  // Check for trapped assets
  const trapped = await api.query.PolkadotXcm.AssetTraps.getEntries();

  if (trapped.length > 0) {
    console.log("Found trapped assets:", trapped);

    // Claim them
    for (const [hash, assets] of trapped) {
      const claimTx = api.tx.PolkadotXcm.claim_assets({
        assets,
        beneficiary: myAccount
      });

      await claimTx.signAndSubmit(signer);
    }
  }
}
```

## Fee Estimation

### Estimate XCM Fees

```typescript
async function estimateXcmFee(dest, assets) {
  // Query fee for transfer
  const feeInfo = await api.tx.PolkadotXcm.transfer_assets({
    dest,
    beneficiary,
    assets,
    fee_asset_item: 0,
    weight_limit: "Unlimited"
  }).getPaymentInfo(sender);

  return feeInfo.partialFee;
}
```

### Add Fee Buffer

```typescript
async function transferWithFeeBuffer(amount: bigint) {
  const baseFee = await estimateXcmFee(dest, assets);
  const feeBuffer = baseFee * 20n / 100n; // 20% buffer
  const totalFee = baseFee + feeBuffer;

  // Ensure sufficient balance
  const account = await api.query.System.Account.getValue(sender);
  if (account.data.free < amount + totalFee) {
    throw new Error("Insufficient balance including fees");
  }

  return await transferAssets(dest, amount, beneficiary);
}
```

## Multi-Chain Support

### Connect Multiple Chains

```typescript
import { createClient } from "polkadot-api";
import { getWsProvider } from "polkadot-api/ws-provider/web";

const chains = {
  relay: createClient(getWsProvider("wss://westend-rpc.polkadot.io")),
  assetHub: createClient(getWsProvider("wss://westend-asset-hub-rpc.polkadot.io")),
  collectives: createClient(getWsProvider("wss://westend-collectives-rpc.polkadot.io"))
};

// Get typed APIs
const relayApi = chains.relay.getTypedApi(relayDescriptor);
const ahApi = chains.assetHub.getTypedApi(ahDescriptor);
```

### Monitor Multiple Chains

```typescript
function monitorAllChains(chains: Record<string, Client>) {
  Object.entries(chains).forEach(([name, client]) => {
    const api = client.getTypedApi(descriptors[name]);

    api.query.System.Events.watchValue((events) => {
      console.log(`[${name}] Events:`, events.length);
      // Process events
    });
  });
}
```

## Best Practices

- Always validate destinations before transfers
- Use specific weight limits in production
- Monitor for trapped assets
- Test on Chopsticks before mainnet
- Handle all error cases
- Add fee buffers for reliability
- Track XCM message lifecycle
- Clean up subscriptions

## Troubleshooting

### Transfer Not Arriving

1. Check destination chain supports the asset
2. Verify asset is registered on destination
3. Ensure sufficient fees
4. Check for trapped assets
5. Monitor events on both chains

### Assets Trapped

```typescript
// Query trapped assets
const trapped = await api.query.PolkadotXcm.AssetTraps.getEntries();

// Claim them
await api.tx.PolkadotXcm.claim_assets({ assets, beneficiary }).signAndSubmit(signer);
```

### Chopsticks Issues

```bash
# Clear cache
rm -rf .chopsticks

# Use specific block
# In chopsticks.yml: block: 12345678

# Check logs
npm run chopsticks -- --log-level=debug
```

## Resources

- [XCM Docs](https://wiki.polkadot.network/docs/learn-xcm)
- [XCM Format](https://github.com/paritytech/xcm-format)
- [Chopsticks](https://github.com/AcalaNetwork/chopsticks)
- [Asset Transfer API](https://github.com/paritytech/asset-transfer-api)
- [XCM Playground](https://github.com/paritytech/xcm-playground)

## License

MIT OR Apache-2.0
