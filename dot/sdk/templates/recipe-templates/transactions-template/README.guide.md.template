---
title: {{title}}
description: {{description}}

---

# {{title}}

{{description}}

## Overview

A focused guide for implementing blockchain interactions using Polkadot API (PAPI). This guide shows you how to quickly connect to chains, read state, and submit transactions.

**Prerequisites:**
- Node.js 20+
- TypeScript knowledge
- Basic blockchain concepts

## Quick Start

```bash
cd recipes/{{slug}}
npm install
npm test
```

## Implementation

### Client Setup

Create a typed client in `src/client.ts`:

```typescript
import { createClient } from "polkadot-api";
import { getWsProvider } from "polkadot-api/ws-provider/web";
import { ahp } from "@polkadot-api/descriptors";

const provider = getWsProvider("wss://westend-asset-hub-rpc.polkadot.io");
export const client = createClient(provider);
export const api = client.getTypedApi(ahp);
```

**Key points:**
- Use `getWsProvider()` for WebSocket connections
- `getTypedApi()` provides fully typed API based on chain metadata
- Types are auto-generated during `npm install`

### Reading State

Query chain storage:

```typescript
// Constants
const version = await api.constants.System.Version();

// Single storage item
const account = await api.query.System.Account.getValue(address);

// Multiple items
const allAccounts = await api.query.System.Account.getEntries();

// Storage at specific block
const accountAtBlock = await api.query.System.Account.getValue(
  address,
  { at: "best" } // or block hash
);
```

### Subscriptions

Watch for real-time updates:

```typescript
// Watch block numbers
const unsubscribe = api.query.System.Number.watchValue((blockNum) => {
  console.log("Block:", blockNum);
});

// Watch storage changes
api.query.System.Account.watchValue(address, (account) => {
  console.log("Balance:", account.data.free);
});

// Clean up when done
unsubscribe();
```

### Creating Transactions

Construct transaction calls:

```typescript
// Balance transfer
const tx = api.tx.Balances.transfer_allow_death({
  dest: recipientAddress,
  value: 1_000_000_000n, // Amount in smallest unit
});

// Batch multiple calls
const batchTx = api.tx.Utility.batch({
  calls: [
    api.tx.Balances.transfer_allow_death({ dest: addr1, value: amount1 }),
    api.tx.Balances.transfer_allow_death({ dest: addr2, value: amount2 }),
  ],
});

// Inspect transaction before signing
const encoded = await tx.getEncodedData();
console.log("Tx size:", encoded.length, "bytes");
```

### Signing and Submitting

Submit transactions with different methods:

```typescript
import { getPolkadotSigner } from "polkadot-api/signer";

// Method 1: Simple submit
const result = await tx.signAndSubmit(signer);
console.log("Tx hash:", result.txHash);

// Method 2: Watch status
const unsub = tx.signSubmitAndWatch(signer, {
  onInBlock: (evt) => console.log("In block:", evt.block.hash),
  onFinalized: (evt) => console.log("Finalized:", evt.block.hash),
  onError: (err) => console.error("Error:", err),
});

// Method 3: Get signed transaction without submitting
const signedTx = await tx.sign(signer);
// Submit later: await signedTx.submit();
```

### Account Management

Create signers from different sources:

```typescript
import { Sr25519 } from "@polkadot-labs/hdkd";
import { getPolkadotSignerFromPjs } from "@polkadot-labs/hdkd-helpers";

// From mnemonic
const mnemonic = "your twelve word mnemonic phrase here";
const keyring = Sr25519.fromMnemonic(mnemonic);
const signer = getPolkadotSignerFromPjs(keyring);

// From seed
const seed = "0x..."; // 32-byte hex seed
const keyring = Sr25519.fromSeed(hexToBytes(seed));
const signer = getPolkadotSignerFromPjs(keyring);

// From extension (in browser)
const signer = getPolkadotSigner(extensionConnector);
```

## Usage Patterns

### Pattern 1: Query Multiple Storage Items

```typescript
// Parallel queries
const [balance, nonce, block] = await Promise.all([
  api.query.System.Account.getValue(address),
  api.query.System.Number.getValue(),
  client.getFinalizedBlock(),
]);
```

### Pattern 2: Event Filtering

```typescript
api.query.System.Events.watchValue((events) => {
  const transfers = events.filter((e) => e.type === "Balances.Transfer");
  for (const transfer of transfers) {
    console.log("Transfer:", transfer.data);
  }
});
```

### Pattern 3: Error Handling

```typescript
try {
  const result = await tx.signAndSubmit(signer);
  console.log("Success:", result.txHash);
} catch (error) {
  if (error.type === "Invalid") {
    console.error("Invalid tx:", error.message);
  } else if (error.type === "Exhausted") {
    console.error("Tx dropped");
  } else {
    console.error("Unknown error:", error);
  }
}
```

### Pattern 4: Conditional Transactions

```typescript
// Check condition before submitting
const account = await api.query.System.Account.getValue(address);
const balance = account.data.free;

if (balance > requiredAmount) {
  await tx.signAndSubmit(signer);
} else {
  throw new Error("Insufficient balance");
}
```

## Testing

### Basic Test Structure

```typescript
import { describe, it, expect, beforeAll, afterAll } from "vitest";
import { client, api } from "../src/client";

describe("Chain Interactions", () => {
  afterAll(() => {
    client.destroy(); // Clean up connection
  });

  it("reads chain info", async () => {
    const version = await api.constants.System.Version();
    expect(version.spec_name).toBeDefined();
  });

  it("queries storage", async () => {
    const blockNumber = await api.query.System.Number.getValue();
    expect(blockNumber).toBeGreaterThan(0);
  });
});
```

### Testing Transactions

```typescript
it("constructs transaction", async () => {
  const tx = api.tx.Balances.transfer_allow_death({
    dest: testAddress,
    value: 1_000_000_000n,
  });

  const encoded = await tx.getEncodedData();
  expect(encoded.length).toBeGreaterThan(0);
});

// Don't actually submit in tests unless using testnet
```

### Mocking for Unit Tests

```typescript
import { vi } from "vitest";

// Mock the API for isolated testing
const mockApi = {
  query: {
    System: {
      Account: {
        getValue: vi.fn().mockResolvedValue({
          data: { free: 1000n, reserved: 0n },
        }),
      },
    },
  },
};
```

## Common Tasks

### Task 1: Check Balance

```typescript
async function getBalance(address: string) {
  const account = await api.query.System.Account.getValue(address);
  return {
    free: account.data.free,
    reserved: account.data.reserved,
    total: account.data.free + account.data.reserved,
  };
}
```

### Task 2: Transfer Tokens

```typescript
async function transfer(to: string, amount: bigint) {
  const tx = api.tx.Balances.transfer_allow_death({
    dest: to,
    value: amount,
  });

  return await tx.signAndSubmit(signer);
}
```

### Task 3: Monitor Events

```typescript
async function watchEvents(callback: (event: any) => void) {
  return api.query.System.Events.watchValue((events) => {
    events.forEach(callback);
  });
}
```

### Task 4: Get Transaction Fee

```typescript
async function estimateFee(transaction: any) {
  const paymentInfo = await transaction.getPaymentInfo(address);
  return paymentInfo.partialFee;
}
```

## Performance Tips

### Batch Operations

```typescript
// Batch queries
const results = await Promise.all([
  api.query.System.Account.getValue(addr1),
  api.query.System.Account.getValue(addr2),
  api.query.System.Account.getValue(addr3),
]);

// Batch transactions
const batchTx = api.tx.Utility.batch({ calls });
```

### Use Subscriptions Over Polling

```typescript
// Good: Subscribe to changes
api.query.System.Number.watchValue((block) => {
  console.log("New block:", block);
});

// Bad: Poll repeatedly
setInterval(async () => {
  const block = await api.query.System.Number.getValue();
}, 1000);
```

### Cache Static Data

```typescript
// Cache constants and rarely-changing data
const chainInfo = await api.constants.System.Version();
const cachedSpecName = chainInfo.spec_name;

// Reuse cached value
console.log(cachedSpecName);
```

## Multi-Chain Support

### Connecting to Multiple Chains

```typescript
import { createClient } from "polkadot-api";
import { getWsProvider } from "polkadot-api/ws-provider/web";

const chains = {
  assetHub: createClient(
    getWsProvider("wss://westend-asset-hub-rpc.polkadot.io")
  ),
  relayChain: createClient(
    getWsProvider("wss://westend-rpc.polkadot.io")
  ),
};

// Use different APIs
const ahApi = chains.assetHub.getTypedApi(ahDescriptor);
const relayApi = chains.relayChain.getTypedApi(relayDescriptor);
```

### Generating Types for Multiple Chains

In `package.json`:

```json
{
  "scripts": {
    "generate": "papi add -n paseo_asset_hub ahp && papi add -n paseo pas"
  }
}
```

## License

MIT OR Apache-2.0
