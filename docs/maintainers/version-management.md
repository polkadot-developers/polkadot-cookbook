# Version Management System

The Polkadot Cookbook uses a flexible version management system that allows recipes to specify dependency versions while inheriting defaults from a global configuration.

## Table of Contents

- [Overview](#overview)
- [How It Works](#how-it-works)
- [File Format](#file-format)
- [Merge Behavior](#merge-behavior)
- [CLI Commands](#cli-commands)
- [CI Integration](#ci-integration)
- [SDK Usage](#sdk-usage)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)

## Overview

The version management system enables:

âœ… **Global defaults** - Set default versions for all recipes
âœ… **Recipe overrides** - Override versions on a per-recipe basis
âœ… **Source tracking** - Know whether a version is global or recipe-specific
âœ… **CI integration** - Automatic version resolution in GitHub Actions
âœ… **CLI tooling** - Commands for viewing and validating versions

## How It Works

### Architecture

1. **Global Configuration** (`versions.yml` at repository root)
   - Defines default versions for all dependencies
   - Single source of truth for versions

2. **Recipe Overrides** (`recipes/<slug>/versions.yml`)
   - Optional per-recipe version overrides
   - Only specify versions that differ from global

3. **Resolution** (merge on demand)
   - CLI/SDK merges global + recipe versions
   - Recipe versions take precedence
   - Result includes source tracking

### Workflow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  versions.yml   â”‚  Global defaults
â”‚  (repo root)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                         â”‚
         â–¼                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ recipes/foo/    â”‚       â”‚ recipes/bar/    â”‚
â”‚ versions.yml    â”‚       â”‚ versions.yml    â”‚
â”‚ (overrides)     â”‚       â”‚ (overrides)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                         â”‚
         â–¼                         â–¼
    Resolved for foo          Resolved for bar
```

## File Format

### Global Versions (`versions.yml`)

Located at repository root:

```yaml
versions:
  rust: "1.86"
  polkadot_omni_node: "0.5.0"
  chain_spec_builder: "10.0.0"
  frame_omni_bencher: "0.13.0"

metadata:
  schema_version: "1.0"
```

### Recipe Overrides (`recipes/<slug>/versions.yml`)

Optional file in recipe directory:

```yaml
# Recipe-specific version overrides
# Only specify versions that differ from global
versions:
  polkadot_omni_node: "0.6.0"  # Override
  chain_spec_builder: "11.0.0"  # Override
  # rust and frame_omni_bencher inherited from global

metadata:
  schema_version: "1.0"
```

**Template (auto-generated by CLI):**

```yaml
# Recipe-specific version overrides
# These versions will override the global versions.yml on a per-key basis.
# Uncomment and modify the versions you need to override for this recipe.

versions:
  # rust: "1.86"
  # polkadot_omni_node: "0.5.0"
  # chain_spec_builder: "10.0.0"
  # frame_omni_bencher: "0.13.0"

metadata:
  schema_version: "1.0"
```

## Merge Behavior

The system automatically merges global and recipe-specific versions:

### Algorithm

1. Load global `versions.yml`
2. Load recipe `versions.yml` (if exists)
3. Merge with recipe taking precedence
4. Track source for each version

### Example

**Given:**
```yaml
# Global versions.yml
versions:
  rust: "1.86"
  polkadot_omni_node: "0.5.0"
  chain_spec_builder: "10.0.0"
  frame_omni_bencher: "0.13.0"

# Recipe versions.yml
versions:
  polkadot_omni_node: "0.6.0"
  chain_spec_builder: "11.0.0"
```

**Resolved:**
- `rust`: `"1.86"` (from global - not overridden)
- `polkadot_omni_node`: `"0.6.0"` (from recipe - overridden)
- `chain_spec_builder`: `"11.0.0"` (from recipe - overridden)
- `frame_omni_bencher`: `"0.13.0"` (from global - not overridden)

## CLI Commands

The `dot` CLI provides commands for managing versions.

### View Global Versions

```bash
dot versions
```

**Output:**
```
ğŸ“¦ Global versions

  rust                1.86
  polkadot_omni_node  0.5.0
  chain_spec_builder  10.0.0
  frame_omni_bencher  0.13.0
```

### View Recipe Versions

```bash
dot versions my-recipe
```

**Output:**
```
ğŸ“¦ Versions for recipe: my-recipe

  rust                1.86
  polkadot_omni_node  0.6.0
  chain_spec_builder  11.0.0
  frame_omni_bencher  0.13.0
```

### Show Version Sources

Debug which versions come from where:

```bash
dot versions my-recipe --show-source
```

**Output:**
```
ğŸ“¦ Versions for recipe: my-recipe

  rust                1.86   (global)
  polkadot_omni_node  0.6.0  (recipe)
  chain_spec_builder  11.0.0 (recipe)
  frame_omni_bencher  0.13.0 (global)
```

### CI/Automation Format

Export versions as environment variables:

```bash
dot versions my-recipe --ci
```

**Output:**
```
RUST=1.86
POLKADOT_OMNI_NODE=0.6.0
CHAIN_SPEC_BUILDER=11.0.0
FRAME_OMNI_BENCHER=0.13.0
```

**Usage in scripts:**
```bash
eval $(dot versions my-recipe --ci)
echo "Using Rust $RUST"
```

### Validate Version Keys

Check for unknown keys:

```bash
dot versions my-recipe --validate
```

**Output (valid):**
```
âœ… All version keys are valid!

Found 4 valid version keys:
  â€¢ rust
  â€¢ polkadot_omni_node
  â€¢ chain_spec_builder
  â€¢ frame_omni_bencher
```

**Output (warnings):**
```
âš ï¸  Validation warnings:

  â€¢ Unknown key: 'unknown_tool'

Known keys:
  â€¢ rust
  â€¢ polkadot_omni_node
  â€¢ chain_spec_builder
  â€¢ frame_omni_bencher

Note: Unknown keys will be ignored by the workflow.
```

## CI Integration

GitHub Actions workflows use the version system to ensure each recipe is tested with its specified dependency versions.

### Workflow Example

```yaml
- name: Build CLI
  run: cargo build --release

- name: Resolve tool versions
  id: resolve
  run: |
    # Use CLI to resolve versions
    eval $(./target/release/dot versions ${{ matrix.slug }} --ci)
    echo "rust=$RUST" >> $GITHUB_OUTPUT
    echo "chain-spec-builder=$CHAIN_SPEC_BUILDER" >> $GITHUB_OUTPUT
    echo "omni-node=$POLKADOT_OMNI_NODE" >> $GITHUB_OUTPUT

- name: Setup Rust with resolved version
  uses: dtolnay/rust-toolchain@stable
  with:
    toolchain: ${{ steps.resolve.outputs.rust }}

- name: Install tools
  run: |
    cargo install chain-spec-builder --version ${{ steps.resolve.outputs.chain-spec-builder }}
    cargo install polkadot-omni-node --version ${{ steps.resolve.outputs.omni-node }}

- name: Run tests
  run: cargo test
```

### Version Resolution Flow

```
GitHub Actions Workflow
         â”‚
         â”œâ”€ 1. Build CLI
         â”‚
         â”œâ”€ 2. Run `dot versions <recipe> --ci`
         â”‚    â†“
         â”‚    â”œâ”€ Load global versions.yml
         â”‚    â”œâ”€ Load recipe versions.yml
         â”‚    â”œâ”€ Merge (recipe takes precedence)
         â”‚    â””â”€ Export as environment variables
         â”‚
         â”œâ”€ 3. Use resolved versions
         â”‚    â”œâ”€ Setup Rust toolchain
         â”‚    â”œâ”€ Install dependencies
         â”‚    â””â”€ Run tests
         â”‚
         â””â”€ âœ… Test with correct versions
```

## SDK Usage

The SDK provides programmatic access to version management.

### Load Global Versions

```rust
use polkadot_cookbook_core::version::load_global_versions;
use std::path::Path;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let repo_root = Path::new(".");
    let global = load_global_versions(repo_root).await?;

    for (name, version) in &global.versions {
        println!("{}: {}", name, version);
    }

    Ok(())
}
```

### Resolve Recipe Versions

```rust
use polkadot_cookbook_core::version::{
    resolve_recipe_versions,
    VersionSource,
};
use std::path::Path;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let repo_root = Path::new(".");
    let resolved = resolve_recipe_versions(repo_root, "my-recipe").await?;

    // Access versions
    if let Some(rust_version) = resolved.get("rust") {
        println!("Rust version: {}", rust_version);
    }

    // Check source
    for (name, version) in &resolved.versions {
        let source = match resolved.get_source(name) {
            Some(VersionSource::Global) => "global",
            Some(VersionSource::Recipe) => "recipe",
            None => "unknown",
        };
        println!("{}: {} ({})", name, version, source);
    }

    Ok(())
}
```

## Best Practices

### For Contributors

âœ… **DO:**
- Use global versions unless you have a specific reason to override
- Document why you're overriding in a comment
- Test with both global and recipe versions
- Keep recipe `versions.yml` minimal (only overrides)

âŒ **DON'T:**
- Duplicate all global versions in recipe file
- Override without good reason
- Use `latest` or version ranges

**Good Example:**
```yaml
# Recipe needs newer omni-node for specific feature
versions:
  polkadot_omni_node: "0.6.0"  # Requires XCM v3 support
```

**Bad Example:**
```yaml
# Duplicating all global versions (unnecessary)
versions:
  rust: "1.86"
  polkadot_omni_node: "0.5.0"
  chain_spec_builder: "10.0.0"
  frame_omni_bencher: "0.13.0"
```

### For Maintainers

âœ… **DO:**
- Update global versions carefully (affects all recipes)
- Test after global version updates
- Communicate version changes
- Use semantic versioning

âŒ **DON'T:**
- Make breaking version changes without testing
- Update versions without documenting why
- Force all recipes to use same versions

### When to Override

**Override recipe versions when:**

1. **Specific feature requirements**
   ```yaml
   # Recipe uses XCM v3 features
   polkadot_omni_node: "0.6.0"
   ```

2. **Compatibility constraints**
   ```yaml
   # Recipe not yet compatible with latest
   polkadot_omni_node: "0.5.0"
   ```

3. **Testing newer versions**
   ```yaml
   # Testing compatibility with next release
   polkadot_omni_node: "0.7.0-rc1"
   ```

**Keep global when:**

1. No specific requirements
2. Standard recipe functionality
3. Prefer latest stable versions

## Troubleshooting

### Version Resolution Fails

**Symptom:** `dot versions` command fails

**Causes:**
- Invalid YAML syntax in `versions.yml`
- Missing `versions.yml` file
- Recipe directory doesn't exist

**Solution:**
```bash
# Validate YAML syntax
yq eval versions.yml

# Check file exists
ls -la versions.yml
ls -la recipes/my-recipe/versions.yml

# Use validation flag
dot versions my-recipe --validate
```

### Wrong Versions Resolved

**Symptom:** Expected version doesn't match resolved version

**Causes:**
- Typo in recipe `versions.yml`
- Key name doesn't match global `versions.yml`
- Recipe file not being read

**Solution:**
```bash
# Debug with show-source
dot versions my-recipe --show-source

# Check exact key names
yq eval '.versions | keys' versions.yml
yq eval '.versions | keys' recipes/my-recipe/versions.yml
```

### CI Uses Wrong Versions

**Symptom:** Workflow uses unexpected versions

**Causes:**
- CLI not built before version resolution
- Wrong recipe slug in workflow
- Cache issues

**Solution:**
```bash
# Check workflow logs for version resolution step
# Verify CLI is built first
# Check matrix slug matches recipe directory name
```

### Unknown Version Key Warning

**Symptom:** Validation shows unknown keys

**Causes:**
- Typo in key name
- Using unsupported dependency
- Key not in global `versions.yml`

**Solution:**
```bash
# Check valid keys
dot versions --validate

# Compare with global
cat versions.yml

# Fix typos in recipe versions.yml
```

## Related Documentation

- [Release Process](release-process.md) - How versions are used in releases
- [Workflows](workflows.md) - CI integration details
- [Version Testing](../automation/version-workflows.md) - Testing version workflows
- [Versions Schema](../reference/versions-schema.md) - File format specification

---

[â† Back to Maintainers Guide](README.md)
